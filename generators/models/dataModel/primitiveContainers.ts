const standaloneTypes = {
    "byte": "number",
    "ushort": "number",
    "uint": "number",
    "ulong": "number",

    "sbyte": "number",
    "short": "number",
    "int": "number",
    "long": "number",

    "float": "number",
    "double": "number",

    "decimal": "number",

    "bool": "boolean",

    "char": "string",
    "string": "string | null",
    "Uri": "string",

    "DateTime": "string",
    "TimeSpan": "string",

    "color": "color",
    "colorX": "colorX",
    "color32": "color32",
}

type standaloneTypesEnum = keyof typeof standaloneTypes

const nonNullablesType: standaloneTypesEnum[] = [
    "string",
    "Uri",
]

const vectorTypes: standaloneTypesEnum[] = [
    "float",
    "double",

    "byte",
    "ushort",
    "uint",
    "ulong",

    "sbyte",
    "short",
    "int",
    "long",

    "bool",
]

const quaternionTypes: standaloneTypesEnum[] = [
    "float",
    "double",
]

const matrixTypes: standaloneTypesEnum[] = [
    "float",
    "double",
]

// --- //

const primitiveTypes: [string, string][] = []

primitiveTypes.push(...Object.entries(standaloneTypes))

for(let dim=2; dim<=4; dim++) primitiveTypes.push(...vectorTypes.map(x => [`${x}${dim}`, `${standaloneTypes[x]}${dim}`] as [string, string]))

primitiveTypes.push(...quaternionTypes.map(x => [`${x}Q`, `numberQ`] as [string, string]))

for(let dim=2; dim<=4; dim++) primitiveTypes.push(...matrixTypes.map(x => [`${x}${dim}x${dim}`, `number${dim}x${dim}`] as [string, string]))

// --- //

const equiv: [string, string][] = []

for(const [resoniteType, tsType] of primitiveTypes){
    if(resoniteType !== "string") equiv.push([resoniteType, tsType], [`${resoniteType}[]`, `${tsType}[]`])
    else equiv.push(["string", "string | null"], ["string[]", "(string | null)[]"])

    if(!nonNullablesType.includes(resoniteType as standaloneTypesEnum)) equiv.push([`${resoniteType}?`, `${tsType} | null`])
}
equiv.push(["enum", "string"], ["enum?", "string | null"])

const out =
`import type { number2, boolean2, number3, boolean3, number4, boolean4, numberQ, number2x2, number3x3, number4x4, color, colorX, color32 } from "./primitives.ts"

// AUTOGENERATED!!! Modify the matching file in /generators

export type PrimitiveType = ${primitiveTypes.map(x => `"${x[0]}"`).join("|")}
export type NullableType = ${primitiveTypes.filter(x => !(nonNullablesType as string[]).includes(x[0])).map(x => `"${x[0]}?"`).join("|")}
export type FieldType = PrimitiveType | NullableType | "enum" | "enum?"

export type ArrayType = ${primitiveTypes.map(x => `"${x[0]}[]"`).join("|")}

export type ResoToTS<T extends FieldType | ArrayType> = {
${equiv.map(([a, b]) => `"${a}": ${b}`).join(`\n`)}
}[T]

const equivalentTypes: Record<string, string> = {
${equiv.map(([a, b]) => `"${a}": "${b}"`).join(`,\n`)},
}

/** Get the corresponding TS type string from a Resonite type string.
 * This only includes Field and Array types. \`"list"\` and \`"syncObject"\` will return \`undefined\` 
 * 
 * Note : strings in Resonite are always nullable. (\`"string"\` -> \`"string | null"\`)
 * 
 * See also \`isNullableType\`, \`isArrayType\`, \`getPrimitiveType\`. */
export function getTsTypeFromResoniteType(type: string): string {
    return equivalentTypes[type]
}
`

// --- //

Deno.writeTextFileSync("./link/models/dataModel/primitiveContainers.ts", out);
console.log(`"primitiveContainers.ts" generated.`)